// --- BEGIN SOUNDCUE BACKPORT ---

var protected DRAudioComponent DialogAudioComp;

struct DelayedSpeakLineParamStructCustom extends DelayedSpeakLineParamStruct
{
    var SoundCue CustomAudio;
};

var protected DelayedSpeakLineParamStructCustom DelayedSpeakLineParamsCustom;

// --- END SOUNDCUE BACKPORT ---

var private bool bLeftVehicleRecently;

simulated event PostBeginPlay()
{
    super.PostBeginPlay();

    if (WorldInfo.NetMode == NM_DedicatedServer)
    {
        DetachComponent(DialogAudioComp);
    }
}

function ClearLeftVehicleFlag()
{
    bLeftVehicleRecently = False;
    ClearTimer('ClearLeftVehicleFlag');
}

function SetLeftVehicleFlag()
{
    bLeftVehicleRecently = True;
    SetTimer(3, False, 'ClearLeftVehicleFlag');
}

simulated function SetPawnElementsByConfig(bool bViaReplication,
    optional ROPlayerReplicationInfo OverrideROPRI)
{
}

simulated function CreatePawnMesh()
{
    local ROMapInfo ROMI;

    if( Health <= 0 )
        return;

    if( HeadAndArmsMIC == none )
        HeadAndArmsMIC = new class'MaterialInstanceConstant';
    if( BodyMIC == none )
        BodyMIC = new class'MaterialInstanceConstant';
    if( HeadgearMIC == none )
        HeadgearMIC = new class'MaterialInstanceConstant';
    if( HairMIC == none && HairMICTemplate != none )
        HairMIC = new class'MaterialInstanceConstant';
    if( FPArmsSleeveMaterial == none && FPArmsSleeveMaterialTemplate != none )
        FPArmsSleeveMaterial = new class'MaterialInstanceConstant';

    if( bUseSingleCharacterVariant && BodyMICTemplate_SV != none )
        BodyMIC.SetParent(BodyMICTemplate_SV);
    else
        BodyMIC.SetParent(BodyMICTemplate);

    HeadAndArmsMIC.SetParent(HeadAndArmsMICTemplate);
    HeadgearMIC.SetParent(HeadgearMICTemplate);

    if( FPArmsSleeveMaterial != none )
        FPArmsSleeveMaterial.SetParent(FPArmsSleeveMaterialTemplate);

    if( HairMIC != none )
        HairMIC.SetParent(HairMICTemplate);

    MeshMICs.Length = 0;
    MeshMICs.AddItem(BodyMIC);
    MeshMICs.AddItem(HeadAndArmsMIC);
    // MeshMICs.AddItem(HeadgearMIC);

    if( HairMIC != none )
        MeshMICs.AddItem(HairMIC);

    if( ThirdPersonHeadgearMeshComponent.AttachedToSkelComponent != none )
        mesh.DetachComponent(ThirdPersonHeadgearMeshComponent);
    if( FaceItemMeshComponent.AttachedToSkelComponent != none )
        mesh.DetachComponent(FaceItemMeshComponent);
    if( FacialHairMeshComponent.AttachedToSkelComponent != none )
        mesh.DetachComponent(FacialHairMeshComponent);
    if( ThirdPersonHeadAndArmsMeshComponent.AttachedToSkelComponent != none )
        DetachComponent(ThirdPersonHeadAndArmsMeshComponent);
    if( TrapDisarmToolMeshTP.AttachedToSkelComponent != none )
        mesh.DetachComponent(TrapDisarmToolMeshTP);

    ROMI = ROMapInfo(WorldInfo.GetMapInfo());

    CompositedBodyMesh = ROMI.GetCachedCompositedPawnMesh(TunicMesh, FieldgearMesh);
    CompositedBodyMesh.Characterization = PlayerHIKCharacterization;

    ROSkeletalMeshComponent(mesh).ReplaceSkeletalMesh(CompositedBodyMesh);

    // mesh.SetMaterial(0, BodyMIC);

    // Be careful here. Soviets need to have their BodyMic applied to their gear mesh
    // for proper wrappings/boot textures but it also seems to run on Finns sometimes.
    // Hopefully this will mitigate that.

//  if (GetTeamNum() == `ALLIES_TEAM_INDEX)
    // if (self.IsA('WWPawnAllies'))
    // {
        // mesh.SetMaterial(1, BodyMIC);
    // }

    ROSkeletalMeshComponent(mesh).GenerateAnimationOverrideBones(HeadAndArmsMesh);

    ThirdPersonHeadAndArmsMeshComponent.SetSkeletalMesh(HeadAndArmsMesh);
    ThirdPersonHeadAndArmsMeshComponent.SetMaterial(0, HeadAndArmsMIC);
    ThirdPersonHeadAndArmsMeshComponent.SetParentAnimComponent(mesh);
    ThirdPersonHeadAndArmsMeshComponent.SetShadowParent(mesh);
    ThirdPersonHeadAndArmsMeshComponent.SetLODParent(mesh);

    AttachComponent(ThirdPersonHeadAndArmsMeshComponent);

    if( HeadgearMesh != none )
    {
        AttachNewHeadgear(HeadgearMesh);
    }

    if( FaceItemMesh != none )
    {
        AttachNewFaceItem(FaceItemMesh);
    }

    if( FacialHairMesh != none )
    {
        AttachNewFacialHair(FacialHairMesh);
    }

    if ( ClothComponent != None )
    {
        ClothComponent.SetParentAnimComponent(mesh);
        ClothComponent.SetShadowParent(mesh);
        AttachComponent(ClothComponent);
        ClothComponent.SetEnableClothSimulation(true);
        ClothComponent.SetAttachClothVertsToBaseBody(true);
    }

    if ( ArmsMesh != None )
    {
        ArmsMesh.SetSkeletalMesh(ArmsOnlyMeshFP);
    }

    if ( BandageMesh != none )
    {
        BandageMesh.SetSkeletalMesh(BandageMeshFP);
        BandageMesh.SetHidden(true);
    }

    if ( ROMI != none )
    {
        if ( TrapDisarmToolMesh != none )
        {
            TrapDisarmToolMesh.SetSkeletalMesh(GetTrapDisarmToolMesh(true));
        }
        if ( TrapDisarmToolMeshTP != none )
        {
            TrapDisarmToolMeshTP.SetSkeletalMesh(GetTrapDisarmToolMesh(false));
        }
    }

    if ( TrapDisarmToolMesh != none )
    {
        TrapDisarmToolMesh.SetHidden(true);
    }

    if ( TrapDisarmToolMeshTP != none )
    {
        Mesh.AttachComponentToSocket(TrapDisarmToolMeshTP, GrenadeSocket);
        TrapDisarmToolMeshTP.SetHidden(true);
    }

    if ( bOverrideLighting )
    {
        ThirdPersonHeadAndArmsMeshComponent.SetLightingChannels(LightingOverride);
        ThirdPersonHeadgearMeshComponent.SetLightingChannels(LightingOverride);
    }

    if( WorldInfo.NetMode == NM_DedicatedServer )
    {
        mesh.ForcedLODModel = 1000;
        ThirdPersonHeadAndArmsMeshComponent.ForcedLodModel = 1000;
        ThirdPersonHeadgearMeshComponent.ForcedLodModel = 1000;
        FaceItemMeshComponent.ForcedLodModel = 1000;
        FacialHairMeshComponent.ForcedLodModel = 1000;
    }
}

simulated function AttachNewHeadgear(SkeletalMesh NewHeadgearMesh)
{
    local SkeletalMeshSocket HeadSocket;

    ThirdPersonHeadgearMeshComponent.SetSkeletalMesh(NewHeadgearMesh);
    // ThirdPersonHeadgearMeshComponent.SetMaterial(0, HeadgearMIC);

    HeadSocket = ThirdPersonHeadAndArmsMeshComponent.GetSocketByName(HeadgearAttachSocket);

    if( HeadSocket != none )
    {
        if( mesh.MatchRefBone(HeadSocket.BoneName) != INDEX_NONE )
        {
            ThirdPersonHeadgearMeshComponent.SetShadowParent(mesh);
            ThirdPersonHeadgearMeshComponent.SetLODParent(mesh);
            mesh.AttachComponent( ThirdPersonHeadgearMeshComponent, HeadSocket.BoneName, HeadSocket.RelativeLocation, HeadSocket.RelativeRotation, HeadSocket.RelativeScale);
        }
    }
}

function TakeFallingDamage()
{
    local float EffectiveSpeed;
    local float SpeedOverMax;
    local float HurtRatio;
    local float ActualDamage;
    local float Threshold1;
    local float Threshold2;
    local float SpeedXY;

    Threshold1 = -0.5 * MaxFallSpeed;
    Threshold2 = -1 * MaxFallSpeed;

    // For exiting vehicles at high speed.
    // TODO: needs fine tuning.
    SpeedXY = VSize2D(Velocity);

    if (Velocity.Z < Threshold1 || SpeedXY > Abs(Threshold1))
    {
        if (Role == ROLE_Authority)
        {
            MakeNoise(1.0);
            if (Velocity.Z < Threshold2 || SpeedXY > Abs(Threshold2))
            {
                if (bLeftVehicleRecently)
                {
                    EffectiveSpeed = FMax(Velocity.Z * -1, SpeedXY);
                }
                else
                {
                    EffectiveSpeed = Velocity.Z * -1;
                }

                if (TouchingWaterVolume())
                {
                    EffectiveSpeed -= 250;
                    // Velocity.Z += 100;
                }
                if (EffectiveSpeed > MaxFallSpeed)
                {
                    // See how much we are over the MaxFallSpeed, and scale
                    // damage as a function of how far over the MaxFallSpeed
                    // we are in relation to the LethalFallSpeed
                    SpeedOverMax = EffectiveSpeed - MaxFallSpeed;
                    HurtRatio = SpeedOverMax/(LethalFallSpeed - MaxFallSpeed);

                    ActualDamage = 100 * HurtRatio;

                    // reduce the zone health by the actual damage, and prevent the player from taking negative zone damage
                    // Damage the legs
                    if( ActualDamage > 35 )
                    {
                        // Slow the player down if they hurt their legs badly enough
                        if( ROGameInfo(WorldInfo.Game) != none && ROGameInfo(WorldInfo.Game).bLegDamageSlowsPlayer )
                        {
                            LegInjuryTime = WorldInfo.TimeSeconds;
                            LegInjuryAmount = 255;
                            SetSprinting(false);
                        }

                        // Right Thigh
                        PlayerHitZones[14].ZoneHealth -= Min(ActualDamage, Max(PlayerHitZones[14].ZoneHealth, 0));
                        PackHitZoneHealth(14); // Pack this Hit Zone's new Health into the replicated array

                        // Left Thigh
                        PlayerHitZones[18].ZoneHealth -= Min(ActualDamage, Max(PlayerHitZones[18].ZoneHealth, 0));
                        PackHitZoneHealth(18); // Pack this Hit Zone's new Health into the replicated array
                    }

                    if( ActualDamage > 15 )
                    {
                        // Right Calf
                        PlayerHitZones[16].ZoneHealth -= Min(ActualDamage, Max(PlayerHitZones[16].ZoneHealth, 0));
                        PackHitZoneHealth(16); // Pack this Hit Zone's new Health into the replicated array

                        // Left Calf
                        PlayerHitZones[20].ZoneHealth -= Min(ActualDamage, Max(PlayerHitZones[20].ZoneHealth, 0));
                        PackHitZoneHealth(20); // Pack this Hit Zone's new Health into the replicated array
                    }

                    if( ActualDamage > 0 )
                    {
                        // Right Foot
                        PlayerHitZones[17].ZoneHealth -= Min(ActualDamage, Max(PlayerHitZones[17].ZoneHealth, 0));
                        PackHitZoneHealth(17); // Pack this Hit Zone's new Health into the replicated array

                        // Left Foot
                        PlayerHitZones[21].ZoneHealth -= Min(ActualDamage, Max(PlayerHitZones[21].ZoneHealth, 0));
                        PackHitZoneHealth(21); // Pack this Hit Zone's new Health into the replicated array
                    }
                    //`log("ActualDamage Is "$ActualDamage$" HurtRatio = "$HurtRatio$" EffectiveSpeed = "$EffectiveSpeed$" MaxFallSpeed = "$MaxFallSpeed$" LethalFallSpeed = "$LethalFallSpeed);

                    TakeDamage(100 * HurtRatio, None, Location, vect(0,0,0), class'DmgType_Fell');
                }
            }
        }
    }
    else if (Velocity.Z < -1.4 * JumpZ)
        MakeNoise(0.5);
    else if ( Velocity.Z < -0.8 * JumpZ )
        MakeNoise(0.2);
}

function bool IsInCamo()
{
    return False;
}

// --- BEGIN SOUNDCUE BACKPORT ---

simulated function bool IsSpeakingCustom()
{
    if (DialogAkComp != None)
    {
        if (DialogAudioComp == None)
        {
            // caution: this is a wwise thread query so watch perf!
            return DialogAkComp.IsPlaying();
        }
        else
        {
            return DialogAkComp.IsPlaying() && DialogAudioComp.IsPlaying();
        }
    }

    return false;
}

simulated final function bool SpeakLineCustom(Actor Addressee, AkEvent Audio, String DebugText,
    float DelaySec, optional ESpeechPriority Priority, optional SpeechInterruptCondition IntCondition,
    optional bool bNoHeadTrack, optional int BroadcastFilter, optional bool bSuppressSubtitle,
    optional Soundcue CustomAudio)
{
    local bool bInterrupt;

    `log("SpeakLineCustom() CustomAudio = " $ CustomAudio, `DEBUG_VOICECOMS, 'DRAudio');

    // Vanilla handling for vanilla audio.
    if (CustomAudio == None)
    {
        return SpeakLine(Addressee, Audio, DebugText, DelaySec, Priority,
            IntCondition, bNoHeadTrack, BroadcastFilter, bSuppressSubtitle);
    }

    switch (IntCondition)
    {
        case SIC_Never:
            bInterrupt = false;
            break;
        case SIC_IfHigher:
            bInterrupt = (Priority > CurrentSpeechPriority) ? true : false;
            break;
        case SIC_IfSameOrHigher:
            bInterrupt = (Priority >= CurrentSpeechPriority) ? true : false;
            break;
        case SIC_Always:
            bInterrupt = true;
            break;
    }

    if ( bInterrupt || !IsSpeakingCustom() )
    {
        //`log("Speaking Line" @ ( !bSpeaking || bInterrupt ));

        DelayedSpeakLineParamsCustom.Addressee = Addressee;
        DelayedSpeakLineParamsCustom.CustomAudio = CustomAudio;
        DelayedSpeakLineParamsCustom.DebugText = DebugText;
        DelayedSpeakLineParamsCustom.bNoHeadTrack = bNoHeadTrack;
        DelayedSpeakLineParamsCustom.Priority = Priority;
        DelayedSpeakLineParamsCustom.BroadcastFilter = ESpeakLineBroadcastFilter(BroadcastFilter);
        DelayedSpeakLineParamsCustom.bSuppressSubtitle = bSuppressSubtitle;
        DelayedSpeakLineParamsCustom.DelayTime = DelaySec;

        if (DelaySec > 0.f)
        {
//          `log("queuing line");
            // play later
            SetTimer(DelaySec, FALSE, 'PlayQueuedSpeakLine');
        }
        else
        {
//          `log("playing now");
            // play now!
            PlayQueuedSpeakLine();
        }

        bNetDirty = true; // have to force because struct member assignment doesn't do it automatically
        //NetUpdateTime = WorldInfo.TimeSeconds - 1.0f;

        return TRUE;
    }

    return FALSE;
}

simulated private function PlayQueuedSpeakLine()
{
    local bool bVersusMulti;
    local PlayerController LocalPC;
    local bool bLocalPlayersTurretPawn;
    local bool bAllowSpatialization;
    local bool bCustomAudio;

    if ( DialogAkComp == None || bPlayedDeath )
    {
        return;
    }

    // Handle current speech, if any.
    DialogAkComp.StopEvents();
    DialogAudioComp.Stop();

    bVersusMulti = true;

    if (DelayedSpeakLineParamsCustom.CustomAudio != None)
    {
        if (!DialogAudioComp.bAttached)
        {
            AttachComponent(DialogAudioComp);
        }

        bCustomAudio = True;

        `log("PlayQueuedSpeakLine(): bCustomAudio = " $ bCustomAudio, `DEBUG_VOICECOMS, 'DRAudio');
    }

    if (DelayedSpeakLineParams.Audio != none || bCustomAudio)
    {
        if (bVersusMulti)
        {
            if (ShouldFilterOutSpeech(DelayedSpeakLineParams.BroadcastFilter))
            {
                // `log(self@"Skipping line"@IsLocallyControlled());
                return;
            }
        }

        if (!DialogAkComp.bAttached)
        {
            AttachComponent(DialogAkComp);
        }

        LocalPC = GetALocalPlayerController();

        // Don't spatialize the voice if it is being played from the pawn
        // attached to the turret our local controller is using!
        if (DrivenVehicle != none && ROTurret(DrivenVehicle) != None &&
            DrivenVehicle == LocalPC.Pawn)
        {
            bLocalPlayersTurretPawn = true;
        }

        //DialogAkComp.bAutoDestroy = true;
        //DialogAkComp.Location = Location;
        bAllowSpatialization = Controller != LocalPC && !bLocalPlayersTurretPawn && (LocalPC.ViewTarget != self || !LocalPC.UsingFirstPersonCamera());
        //DialogAkComp.bSuppressSubtitles = DelayedSpeakLineParams.bSuppressSubtitle || ShouldSuppressSubtitlesForQueuedSpeakLine(bVersusMulti);
        //DialogAkComp.OcclusionCheckInterval = (CurrentlySpeakingLine.bAllowSpatialization ? 0.1 : 0.0);
        //DialogAkComp.PitchMultiplier = DelayedSpeakLineParams.PitchMultiplier;
        //DialogAkComp.bAlwaysPlay = DelayedSpeakLineParams.Priority >= Speech_Spawning;

        // @todo: modulate priority based on distance to the player?
        //DialogAkComp.SubtitlePriority = DelayedSpeakLineParams.Priority * SubtitlePriorityScale;

        // jack priority for scripted lines
        // TODO: RO, Cooney, need to reimplement priority
        // CurrentlySpeakingLine.PriorityMultiplier = (DelayedSpeakLineParams.Priority >= Speech_Scripted) ? 5.f : 1.f;

        if (bCustomAudio)
        {
            `log("DialogAudioComp =" $ DialogAudioComp, `DEBUG_VOICECOMS, 'DRAudio');
            `log("CustomAudio     =" $ DelayedSpeakLineParamsCustom.CustomAudio, `DEBUG_VOICECOMS, 'DRAudio');

            DialogAudioComp.SoundCue = DelayedSpeakLineParamsCustom.CustomAudio;
            DialogAudioComp.bAllowSpatialization = bAllowSpatialization;
            DialogAudioComp.VolumeMultiplier = 1.0; // TODO: volume control.
            DialogAudioComp.Play();
        }
        else
        {
            DialogAkComp.PlayEvent(DelayedSpeakLineParams.Audio, bAllowSpatialization);
        }

        //`log(GetFuncName()@"played line "$CurrentlySpeakingLine.SoundCue);
    }

    CurrentSpeechPriority = DelayedSpeakLineParams.Priority;

    ClearTimer('PlayQueuedSpeakLine');      // just in case
}

// --- END SOUNDCUE BACKPORT ---
